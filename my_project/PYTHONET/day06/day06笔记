前请回顾


1. 进程相关函数
    os.getpid()  获取当前进程的pid
    os.getppid()  获取父进程pid
    os._exit()  退出进程
    sys.exit()  退出进程
2.孤儿进程和僵尸进程
    如何避免僵尸进程
    [1] 使用wait, 处理僵尸进程
    [2] 创建二级子进程处理僵尸进程
3.聊天室程序
    [确定需求]-->[基本的技术分析]-->[功能分析]-->[代码实现]-->[代码实现]-->[代码测试完善]

*********************************************************************************
进程创建对象注意:
    *如果父进程先创建对象再创建子进程,则子进程从父进程获取对象,此时父子进程在对象操作上有一定的相互影响
    e.g. 套接字会监听一个端口,文件会有一个偏移量
    *如果父进程先创建子进程,父子进程中各自创建的对象没有任何关联


multiprocessing 模块创建进程

创建进程步骤:
    1. 将需要执行的进程事件封装为函数
    2.使用模块的Process类生成进程对象,并关联函数
    3.可以通过对象的属性设置进程信息
    4.启动进程,执行绑定函数
    5.回收进程

Process()
功能: 创建进程对象
参数: target 必选 绑定的目标函数
     name 给进程起名字, Process-1
     args 元组, 给目标函数传参(位置传参)
     kwargs  字典  给target目标函数传参 键值传参

p.start()
功能: 启动进程

*target绑定的函数作为进程函数的执行,进程被创建

p.join([timeout])
功能: 阻塞等待回收进程
参数: 超时时间
注意: *使用multiprocessing创建进程,同样子进程复制父进程的全部代码段,
    父子进程执行互不影响,各自有各自的运行空间,子进程只执行函数部分
    *join会回收子进程,否则会产生僵尸进程

    *multiprocessing中进程往往只用来创建管理子进程,
    具体事件由子进程完成

进程对象属性:
    p.name 进程名称
    p.pid  进程PID号
    p.is_alive()  查看进程的状态
    
                                                       


自定义进程类
步骤: 
    1. 继承于Process类
    2. 编写自己的__init__添加自定义属性
       使用super重新加载父类__init__
    3. 重写run方法
使用:
    1. 使用自定义的类创建进程对象
    2. 使用该对象调用start启动进程,此时会自动执行run函数
    3. 使用该函数调用join()回收进程

进程池
产生原因: 如果有大量任务需要多进程完成,则可能需要频繁的创建删除进程,给计算机带来的压力较大.
原理: 创建进程池放入一定量的进程,用来处理事件,事件处理完毕后,进程不退出,
     而是继续等待处理其他事件,直到所有待处理事件结束再统一销毁进程池.
     增加进程的重复利用,降低资源消耗.

步骤: 1.创建进程池,添加适当的进程
     2.将要完成的事件放入进程池等待队列
     3.不断取事件交由进程池中的进程完成,直到所有事件处理完毕
     4.关闭进程池,回收进程

from multiprocessing import Pool
pool = Pool(process)
功能: 创建进程池对象
参数: 进程池中进程数量,默认根据系统自动判定

pool.apply_async(func, args, kwds)
功能: 使用进程池中的进程执行函数事件
参数: func 要执行的函数
    args 元组 给func传参
    kwds 字典 给func键值传参
返回值: 函数事件对象,通过get()方法可以获取func的返回值


pool.close()
功能: 关闭进程池,不能再添加新的事件函数

pool.join()
功能: 回收进程池

*进程池事件func一定在进程池创建之前声明

pool.map(fun, iter)
功能: 将要做的事件加入进程池执行
参数: func 要执行的函数
      iter 迭代对象
返回值: 函数返回值列表


进程间通信(IPC)
原因: 空间相对独立,资源无法相互获取,此时在不同进程间需要专门的方法进行通信

进程间通信的方法: 管道  消息队列   共享内存  信号
               信号量  套接字

管道通信(Pipe)
通信原理: 在内存中开辟管道空间,生成管道操作对象,多个进程使用同一个管道对象读写实现通信

from multiprocessing import Pipe

fd1, fd2 = Pipe(duplex = True)
功能: 创建管道
参数: 默认表示双向管道,如果设置为False则表示单向管道
返回值: 表示管道的两端读写对象
       如果是双向管道均可读写
       如果是单向管道则fd1 只读, fd2 只写

fd.recv()
功能: 从管道读取内容,无内容则阻塞
返回值: 读取到的内容

fd.send(data)
功能: 向管道写入内容
参数: 要写如的内容


消息队列
队列: 存储模型,线性的,先进先出原则
原理: 在内存中建立队列模型,进程通过队列对象将消息存入队列,
     或从队列取出消息,完成进程间通信

from multiprocessing import Queue
q = Queue(maxsize)
功能: 创建队列对象
参数: 表示队列中最多存放消息个数
返回值: 队列对象
q.put(data, [block,timeout])
功能: 向队列存入消息
参数: data 要存入的内容
     block 默认队列满时会阻塞,设置为False为非阻塞
     timeout 超时时间,,,给阻塞的超时时间

q.get([block,timeout])
功能: 从队列取出参数
参数: block默认队列为空会阻塞,设置为False则非阻塞
     timeout超时时间
返回值: 取出内容

q.full() 判断队列是否为满
q.empty() 判断队列是否为空
q.qsize() 获取队列中消息个数
q.close() 关闭队列


作业:
    1. multiprocessing创建进程方法整理, 与fork比较
    2.复习http协议

